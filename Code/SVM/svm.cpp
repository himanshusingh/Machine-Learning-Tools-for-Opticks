/*
* The information in this file is
* Copyright(c) 2012, Himanshu Singh <91.himanshu@gmail.com>
* and is subject to the terms and conditions of the
* GNU Lesser General Public License Version 2.1
* The license text is available from   
* http://www.gnu.org/licenses/lgpl.html
*/

#include "AppVerify.h"
#include "DataAccessor.h"
#include "DataAccessorImpl.h"
#include "DataRequest.h"
#include "DesktopServices.h"
#include "ModelServices.h"
#include "PlugInArg.h"
#include "PlugInArgList.h"
#include "PlugInManagerServices.h"
#include "PlugInRegistration.h"
#include "PlugInResource.h"
#include "ProgressTracker.h"
#include "RasterDataDescriptor.h"
#include "RasterUtilities.h"
#include "Signature.h"
#include "SignatureSelector.h"
#include "SpectralUtilities.h"
#include "SpectralGsocVersion.h"
#include "svmDlg.h"
#include "svm.h"

REGISTER_PLUGIN_BASIC(SpectralSVM, SVM);

SVM::SVM()
{
    setName("SVM");
    setDescription("SVM Supervised Classification");
    setDescriptorId("{BB502AE1-081B-46F8-A415-2B3AB03D6CD4}");
    setCopyright(SPECTRAL_GSOC_COPYRIGHT);
    setVersion(SPECTRAL_GSOC_VERSION_NUMBER);
    setProductionStatus(SPECTRAL_GSOC_IS_PRODUCTION_RELEASE);
    setAbortSupported(true);
    setMenuLocation("[SpectralGsoc]/SVM");
}

SVM::~SVM()
{}

bool SVM::getInputSpecification(PlugInArgList*& pInArgList)
{
    pInArgList = Service<PlugInManagerServices>()->getPlugInArgList();
    VERIFY(pInArgList != NULL);
    VERIFY(pInArgList->addArg<Progress>(Executable::ProgressArg(), NULL, Executable::ProgressArgDescription()));

    if (isBatch() == true)
    {
        VERIFY(pInArgList->addArg<bool>("Is Predict", static_cast<bool>(false), "True if plugin is run for prediction."
            "False if plugin is run for training on input data."));
        VERIFY(pInArgList->addArg< std::vector<Signature*> >("Signatures to predict", NULL, "Signature that will be predicted using the model."));

        VERIFY(pInArgList->addArg<std::string>("Kernel Type", static_cast<std::string>("RBF"), "Kernel that will be used to train SVM."));
        VERIFY(pInArgList->addArg<std::string>("Model File", NULL, "Model that will be used for prediction."));
        VERIFY(pInArgList->addArg<std::string>("Input Data File", NULL, "Input data to train the SVM."));
        VERIFY(pInArgList->addArg<std::string>("Output Model File", NULL, "Model generated by training will be saved in this file."));

        VERIFY(pInArgList->addArg<double>("C regularisation perameter", static_cast<double>(0.1), "Regularisation perameter for SMO."));
        VERIFY(pInArgList->addArg<double>("Epsilon", static_cast<double>(0.001), "Epsilon value for double comparisons in SMO."));
        VERIFY(pInArgList->addArg<double>("Tolerance", static_cast<double>(0.001), "Tolerance value for SMO algorithm."));
        VERIFY(pInArgList->addArg<double>("Sigma", static_cast<double>(1.0), "Sigma value of RBG kernel function."));
    }
    return true;
}

bool SVM::getOutputSpecification(PlugInArgList*& pOutArgList)
{
    return true;
}

bool SVM::execute(PlugInArgList* pInArgList, PlugInArgList* pOutArgList)
{
    if (pInArgList == NULL)
    {
        return false;
    }

    // Begin extracting input arguments.
    ProgressTracker progress(pInArgList->getPlugInArgValue<Progress>(ProgressArg()),
        "Executing SVM", "spectral", "{2A47920B-1847-4316-AE79-6E0C166258DB}");

    std::string kernelType;
    std::string inputFile, outputModelFile, modelFile;
    std::vector<Signature*> toPredict;
    bool isPredict;
    double C, epsilon, tolerance, sigma;
    // If the application is executing in batch mode
    if (isBatch() == true)
    {
        VERIFY(pInArgList->getPlugInArgValue("Is Predict", isPredict) == true);
       
        // When the plugin is run to predict only modelFile and the signatures are required.
        if (isPredict == true)
        {
            VERIFY(pInArgList->getPlugInArgValue("Signatures to predict", toPredict) == true);
            if (toPredict.size() == 0)
            {
                progress.report("No signature selected to predict.", 0, ERRORS, true);
                return false;
            }
            VERIFY(pInArgList->getPlugInArgValue("Model File", modelFile) == true);
        }
        else
        {
            VERIFY(pInArgList->getPlugInArgValue("Kernel Type", kernelType) == true);
            if ((kernelType != "RBF") && (kernelType != "Linear"))
            {
                progress.report("Invalid kernel selected", 0, ERRORS, true);
                return false;
            }
            VERIFY(pInArgList->getPlugInArgValue("Input Data File", inputFile) == true);
            VERIFY(pInArgList->getPlugInArgValue("Output Model File", outputModelFile) == true);
            VERIFY(pInArgList->getPlugInArgValue("C regularisation perameter", C) == true);
            VERIFY(pInArgList->getPlugInArgValue("Epsilon", epsilon) == true);
            VERIFY(pInArgList->getPlugInArgValue("Tolerance", tolerance) == true);
           // Sigma is only needed for the RBF kernel
            if (kernelType == "RBF")
            {
                VERIFY(pInArgList->getPlugInArgValue("Sigma", sigma) == true);
            }
        }
    }
    else
    {
        // Show the GUI dialog
        svmDlg svmDlg(Service<DesktopServices>()->getMainWidget());
        if (svmDlg.exec() != QDialog::Accepted)
        {
            progress.report("Unable to obtain input parameters.", 0, ABORT, true);
            return false;
        }
        
        isPredict = svmDlg.getIsPredict();
        if (isPredict == true)
        {
            modelFile = svmDlg.getModelFileName();
            SignatureSelector signatureSelector(progress.getCurrentProgress(), Service<DesktopServices>()->getMainWidget());
            if (signatureSelector.exec() != QDialog::Accepted)
            {
                progress.report("User Aborted.", 0, ABORT, true);
                return false;
            }
            toPredict = signatureSelector.getExtractedSignatures();

        }
        else
        {
            kernelType = svmDlg.getkernelType();
            inputFile = svmDlg.getInputFileName();
            outputModelFile = svmDlg.getOutputModelFileName();
            C = svmDlg.getC();
            epsilon = svmDlg.getEpsilon();
            tolerance = svmDlg.getTolerance();
            sigma = svmDlg.getSigma();
        }
    }
    // end extracting input arguments


    return true;
}