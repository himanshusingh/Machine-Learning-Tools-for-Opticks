/*
* The information in this file is
* Copyright(c) 2012, Himanshu Singh <91.himanshu@gmail.com>
* and is subject to the terms and conditions of the
* GNU Lesser General Public License Version 2.1
* The license text is available from   
* http://www.gnu.org/licenses/lgpl.html
*/

#include <QtGui/QComboBox>
#include <QtGui/QDialogButtonBox>
#include <QtGui/QFileDialog>
#include <QtGui/QGroupBox>
#include <QtGui/QHeaderView>
#include <QtGui/QLabel>
#include <QtGui/QLayout>
#include <QtGui/QLineEdit>
#include <QtGui/QMessageBox>
#include <QtGui/QPushButton>
#include <QtGui/QRadioButton>
#include <QtGui/QSpinBox>
#include <QtCore/QString>
#include <QtCore/QStringList>
#include <QtGui/QTableWidget>

#include "bpnnDlg.h"
#include "AppVerify.h"
#include "FileBrowser.h"

#include<string>
using std::string;
using std::vector;

bpnnDlg::bpnnDlg(QWidget* pParent) : QDialog(pParent)
{
    setModal(true);
    setWindowTitle("Neural Network Classification");

    // Predict Layout begin
    QLabel* pModelFileLabel = new QLabel("Select BPNN Model file", this);
    pModelFileLabel->setToolTip("Select the model file generated by BPNN.");
    mpModelFile = new FileBrowser;
    mpModelFile->setBrowseCaption("Locate BPNN model file");
    mpModelFile->setBrowseFileFilters("BPNN model file (*.model)");

    QHBoxLayout* pPredictLayout = new QHBoxLayout;
    pPredictLayout->addWidget(pModelFileLabel);
    pPredictLayout->addWidget(mpModelFile);

    QGroupBox* pPredictGroup = new QGroupBox;
    pPredictGroup->setLayout(pPredictLayout);
    pPredictGroup->setEnabled(false);
    // Predict Layout end

    // Train Layout begin
    QLabel* pInputFileLabel = new QLabel("Select Input data file:", this);
    pInputFileLabel->setToolTip("Select the input file generated using classificationData plugin."); 
    mpInputFile = new FileBrowser;
    mpInputFile->setBrowseCaption("Locate supervised classification data file.");
    mpInputFile->setBrowseFileFilters("Supervised Classification Data (*.scd)");

    QLabel* pOutputFileLabel = new QLabel("Select Output Model file:", this);
    pOutputFileLabel->setToolTip("Select the file on which the model learned by BPNN will be written.");
    mpOuputModelFile = new FileBrowser;
    mpOuputModelFile->setBrowseCaption("BPNN model file.");
    mpOuputModelFile->setBrowseFileFilters("BPNN model file (*.model)");
    mpOuputModelFile->setBrowseExistingFile(false);

    QLabel* pLearningRateLabel = new QLabel("LearningRate", this);
    pLearningRateLabel->setToolTip("This ratio influences the speed and quality of learning.");
    mpLearningRate = new QDoubleSpinBox(this);
    mpLearningRate->setToolTip(pLearningRateLabel->toolTip());
    mpLearningRate->setValue(0.1);
    mpLearningRate->setDecimals(4);
    mpLearningRate->setMinimum(0.0);
    mpLearningRate->setMaximum(1.0);

    QLabel* pMomentumLabel = new QLabel("Momentum", this);
    mpMomentum = new QDoubleSpinBox(this);
    mpMomentum->setDecimals(4);
    mpMomentum->setValue(0.1);
    mpMomentum->setMinimum(0.0);
    mpMomentum->setMaximum(1.0);

    QLabel* pIterationsLabel = new QLabel("Iterations", this);
    pIterationsLabel->setToolTip("Number of iterations for which the backpopagation is run.");
    mpIterations = new QSpinBox(this);
    mpIterations->setToolTip(pIterationsLabel->toolTip());
    mpIterations->setValue(100);
    mpIterations->setMinimum(1);
    mpIterations->setMaximum(std::numeric_limits<int>::max());

    QGridLayout* pTrainLayout = new QGridLayout;
    pTrainLayout->addWidget(pLearningRateLabel, 0, 0);
    pTrainLayout->addWidget(mpLearningRate, 0, 1);
    pTrainLayout->addWidget(pMomentumLabel, 1, 0);
    pTrainLayout->addWidget(mpMomentum, 1, 1);
    pTrainLayout->addWidget(pIterationsLabel, 2, 0);
    pTrainLayout->addWidget(mpIterations, 2, 1);
    pTrainLayout->addWidget(pInputFileLabel, 3, 0);
    pTrainLayout->addWidget(mpInputFile, 3, 1);
    pTrainLayout->addWidget(pOutputFileLabel, 4, 0);
    pTrainLayout->addWidget(mpOuputModelFile, 4, 1);
    pTrainLayout->setMargin(10);
    pTrainLayout->setSpacing(5);

    QGroupBox* pTrainGroup = new QGroupBox;
    pTrainGroup->setLayout(pTrainLayout);
    pTrainGroup->setEnabled(false);
    // Train Layout end

    // Button Box Begin
    QDialogButtonBox* pButtonBox = new QDialogButtonBox(QDialogButtonBox::Ok | QDialogButtonBox::Cancel,
        Qt::Horizontal, this);
    // Button Box End

    mpPredictRadio = new QRadioButton("Predict");
    mpTrainRadio = new QRadioButton("Train");

    // Overall Layout begin
    QVBoxLayout* pOverallLayout = new QVBoxLayout(this);
    pOverallLayout->setMargin(10);
    pOverallLayout->setSpacing(5);
    pOverallLayout->addWidget(mpPredictRadio);
    pOverallLayout->addWidget(pPredictGroup);
    pOverallLayout->addWidget(mpTrainRadio);
    pOverallLayout->addWidget(pTrainGroup);
    pOverallLayout->addWidget(pButtonBox);
    // Overall Layout end

    // Make GUI connections
    VERIFYNRV(connect(mpPredictRadio, SIGNAL(toggled(bool)), pPredictGroup, SLOT(setEnabled(bool))));
    VERIFYNRV(connect(mpTrainRadio, SIGNAL(toggled(bool)), pTrainGroup, SLOT(setEnabled(bool))));
    VERIFYNRV(connect(pButtonBox, SIGNAL(accepted()), this, SLOT(accept())));
    VERIFYNRV(connect(pButtonBox, SIGNAL(rejected()), this, SLOT(reject())));

    mpPredictRadio->setChecked(true);
    mpTrainRadio->setChecked(false);
}

bpnnDlg::~bpnnDlg()
{}

bool bpnnDlg::getIsPredict() const
{
    return mpPredictRadio->isChecked();
}

double bpnnDlg::getLearningRate() const
{
    return mpLearningRate->value();
}

double bpnnDlg::getMomentum() const
{
    return mpMomentum->value();
}

int bpnnDlg::getIterations() const
{
    return mpIterations->value();
}

string bpnnDlg::getInputFileName() const
{
    return mpInputFile->getFilename().toStdString();
}

string bpnnDlg::getModelFileName() const
{
    return mpModelFile->getFilename().toStdString();
}

string bpnnDlg::getOutputModelFileName() const
{
    return mpOuputModelFile->getFilename().toStdString();
}

predictionResultDlg::predictionResultDlg(vector<string>& names, vector<string>& classes, QWidget* pParent)
{
    setWindowTitle("Prediction Results");
    QGridLayout* pBox = new QGridLayout(this);
    pBox->setMargin(10);
    pBox->setSpacing(5);

    pResultTable = new QTableWidget(names.size(), 2, this);
    pResultTable->verticalHeader()->hide();
    pResultTable->verticalHeader()->setDefaultSectionSize(20);
    QStringList horizontalHeaderLabels(QStringList() << "Signature" << "Class");
    pResultTable->setHorizontalHeaderLabels(horizontalHeaderLabels);
    //  pResultTable->horizontalHeader()->setDefaultSectionSize(100);
    for (unsigned int i = 0; i < names.size(); i++)
    {
        QTableWidgetItem *pNameItem, *pClassItem;
        pNameItem = new QTableWidgetItem(QString::fromStdString(names[i]));
        pClassItem = new QTableWidgetItem(QString::fromStdString(classes[i]));

        pResultTable->setItem(i, 0, pNameItem);
        pResultTable->setItem(i, 1, pClassItem);
    }

    pBox->addWidget(pResultTable, 0, 0);

    QFrame* pLine = new QFrame(this);
    pLine->setFrameStyle(QFrame::HLine | QFrame::Sunken);
    pBox->addWidget(pLine, 1, 0, 1, 1);

    QDialogButtonBox* pButtonBox = new QDialogButtonBox(QDialogButtonBox::Ok | QDialogButtonBox::Cancel, 
        Qt::Horizontal, this);
    pBox->addWidget(pButtonBox, 2, 0, Qt::AlignRight);

    VERIFYNR(connect(pButtonBox, SIGNAL(accepted()), this, SLOT(accept())));
    VERIFYNR(connect(pButtonBox, SIGNAL(rejected()), this, SLOT(reject())));
}
