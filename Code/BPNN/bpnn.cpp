/*
* The information in this file is
* Copyright(c) 2012, Himanshu Singh <91.himanshu@gmail.com>
* and is subject to the terms and conditions of the
* GNU Lesser General Public License Version 2.1
* The license text is available from   
* http://www.gnu.org/licenses/lgpl.html
*/

#include "AppVerify.h"
#include "DataAccessor.h"
#include "DataAccessorImpl.h"
#include "DataRequest.h"
#include "DesktopServices.h"
#include "ModelServices.h"
#include "PlugInArg.h"
#include "PlugInArgList.h"
#include "PlugInManagerServices.h"
#include "PlugInRegistration.h"
#include "PlugInResource.h"
#include "ProgressTracker.h"
#include "RasterDataDescriptor.h"
#include "RasterUtilities.h"
#include "Signature.h"
#include "SignatureSelector.h"
#include "SpectralUtilities.h"
#include "ML_Tools_Version.h"
#include "bpnn.h"
#include "bpnnDlg.h"
#include "neuralNetwork.h"

#include <vector>
#include <string>
#include <fstream>
using std::vector;
using std::string;

REGISTER_PLUGIN_BASIC(SpectralBPNN, BPNN);

BPNN::BPNN()
{
    setName("BPNN");
    setDescription("BPNN Supervised Classification");
    setDescriptorId("{496D4453-F868-4CE1-A59F-50BC9D18CF4E}");
    setCopyright(ML_TOOLS_COPYRIGHT);
    setVersion(ML_TOOLS_VERSION_NUMBER);
    setProductionStatus(ML_TOOLS_IS_PRODUCTION_RELEASE);
    setAbortSupported(true);
    setMenuLocation("[ML Tools]/BPNN");
}

BPNN::~BPNN()
{}

bool BPNN::getInputSpecification(PlugInArgList*& pInArgList)
{
    pInArgList = Service<PlugInManagerServices>()->getPlugInArgList();
    VERIFY(pInArgList != NULL);
    VERIFY(pInArgList->addArg<Progress>(Executable::ProgressArg(), NULL, Executable::ProgressArgDescription()));

    if (isBatch() == true)
    {
        VERIFY(pInArgList->addArg<bool>("Is Predict", static_cast<bool>(false), "True if plugin is run for prediction."
            "False if plugin is run for training on input data."));
        VERIFY(pInArgList->addArg< vector<Signature*> >("Signatures to predict", NULL, "Signature that will be predicted using the model."));

        VERIFY(pInArgList->addArg<string>("Model File", NULL, "Model that will be used for prediction."));
        VERIFY(pInArgList->addArg<string>("Input Data File", NULL, "Input data to train the BPNN."));
        VERIFY(pInArgList->addArg<string>("Output Model File", NULL, "Model generated by training will be saved in this file."));

        VERIFY(pInArgList->addArg<double>("Learning Rate", static_cast<double>(0.3)));
        VERIFY(pInArgList->addArg<double>("Momentum", static_cast<double>(0.3)));
        VERIFY(pInArgList->addArg<int>("Iterations", static_cast<int>(100)));
    }
    return true;
}

bool BPNN::getOutputSpecification(PlugInArgList*& pOutArgList)
{
    return true;
}

bool BPNN::execute(PlugInArgList* pInArgList, PlugInArgList* pOutArgList)
{
    if (pInArgList == NULL)
    {
        return false;
    }
    // Begin extracting input arguments.
    progress = ProgressTracker(pInArgList->getPlugInArgValue<Progress>(ProgressArg()),
        "Training BPNN", "spectral", "{2A47920B-1847-4316-AE79-6E0C166258DB}");

    double learningRate, momentum;
    int iterations;
    string inputFileName, outputModelFileName, modelFileName;
    vector<Signature*> sigToPredict;
    bool isPredict;
    // If the application is executing in batch mode
    if (isBatch() == true)
    {
        VERIFY(pInArgList->getPlugInArgValue("Is Predict", isPredict) == true);
        // When the plugin is run to predict only modelFileName and the signatures are required.
        if (isPredict == true)
        {
            VERIFY(pInArgList->getPlugInArgValue("Signatures to predict", sigToPredict) == true);
            if (sigToPredict.size() == 0)
            {
                progress.report("No signature selected to predict.", 0, ERRORS, true);
                return false;
            }
            VERIFY(pInArgList->getPlugInArgValue("Model File", modelFileName) == true);
        }
        else
        {
            VERIFY(pInArgList->getPlugInArgValue("Input Data File", inputFileName) == true);
            VERIFY(pInArgList->getPlugInArgValue("Output Model File", outputModelFileName) == true);
            VERIFY(pInArgList->getPlugInArgValue("Learning Rate", learningRate) == true);
            if (learningRate < 0.0 || learningRate > 1.0)
            {
                progress.report("Invalid learning rate", 0, ERRORS, true);
                return false;
            }
            VERIFY(pInArgList->getPlugInArgValue("Momentum", momentum) == true);
            if (momentum < 0.0 || momentum > 1.0)
            {
                progress.report("Invalid momentum", 0, ERRORS, true);
                return false;
            }
            VERIFY(pInArgList->getPlugInArgValue("Iterations", iterations) == true);
            if (iterations <= 0)
            {
                progress.report("Invalid iterations", 0, ERRORS, true);
                return false;
            }
        }
    }
    else
    {
        // Show the GUI dialog
        bpnnDlg bpnnDlg(Service<DesktopServices>()->getMainWidget());
        if (bpnnDlg.exec() != QDialog::Accepted)
        {
            progress.report("Unable to obtain input parameters.", 0, ABORT, true);
            return false;
        }

        isPredict = bpnnDlg.getIsPredict();
        if (isPredict == true)
        {
            // Get the sinatures to predict
            SignatureSelector signatureSelector(progress.getCurrentProgress(), Service<DesktopServices>()->getMainWidget());
            if (signatureSelector.exec() != QDialog::Accepted)
            {
                progress.report("User Aborted.", 0, ABORT, true);
                return false;
            }
            sigToPredict = signatureSelector.getExtractedSignatures();
            // Get the model file name
            modelFileName = bpnnDlg.getModelFileName();
        }
        else
        {
            inputFileName = bpnnDlg.getInputFileName();
            outputModelFileName = bpnnDlg.getOutputModelFileName();
            learningRate = bpnnDlg.getLearningRate();
            momentum = bpnnDlg.getMomentum();
            iterations = bpnnDlg.getIterations();
        }
    }
    // end extracting input arguments

    if (isPredict)
    {
        // Make predictions on the signatures in sigToPredict
        if (sigToPredict.size() == 0)
        {
            progress.report("No signatures selected to predict.", 0, ERRORS, true);
        }

        // Crate a new network
        NeuralNetwork network(this);
        // Read the model
        if (network.readModel(modelFileName) == false)
        {
            return false;
        }
        vector<string> names, classes;

        for (unsigned int i = 0; i < sigToPredict.size(); i++)
        {
            DataVariant reflectanceVariant = sigToPredict[i]->getData("Reflectance");
            vector<double> toPredict;
            reflectanceVariant.getValue(toPredict);
            string prediction;
            // Make prediction using the network
            prediction = network.predict(toPredict);

            names.push_back(sigToPredict[i]->getName());
            classes.push_back(prediction);
        }
        // Display the results
        predictionResultDlg predictionResultDlg(names, classes, Service<DesktopServices>()->getMainWidget());
        predictionResultDlg.exec();
        progress.report("Finished Prediction", 100, NORMAL, true);
    }
    else
    {
        // Create a new network
        NeuralNetwork network(this, learningRate, momentum, iterations);

        if (network.readData(inputFileName) == false)
        {
            return false;
        }
        // Begin training
        if (network.train() == false)
        {
            return false;
        }
        // Save the model
        network.saveModel(outputModelFileName);
        progress.report("Finished training BPNN", 100, NORMAL, true);
    }
    return true;
}